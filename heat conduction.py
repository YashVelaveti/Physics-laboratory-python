# -*- coding: utf-8 -*-
"""Heat conduction lab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PyHbPSQGe7gXGnA7LPMGJFSih7KntfML
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.special import erf

# Parameters
alpha = 1  # Thermal diffusivity
ylim = 0.5  # Limit for the rectangular initial condition
x = np.linspace(-3, 3, 500)  # Spatial domain
t_values = np.linspace(0.01, 0.2, 100)  # Time points

# Initial condition (rectangular pulse)
def u0(x):
    return np.where(np.abs(x) <= ylim, 1, 0)

# Solution to the heat equation using Equation (4)
def u(x, t, ylim, alpha):
    if t == 0:
        return u0(x)
    term1 = erf((ylim - x) / np.sqrt(4 * alpha * t))
    term2 = erf((-ylim - x) / np.sqrt(4 * alpha * t))
    return 0.5 * (term1 - term2)

# Create the figure and axis for animation
fig, ax = plt.subplots()
ax.set_xlim(-3, 3)
ax.set_ylim(0, 1.1)
line, = ax.plot([], [], lw=2)
ax.set_title("Heat Diffusion in 1D")
ax.set_xlabel("x")
ax.set_ylabel("u(x, t)")

# Initialization function
def init():
    line.set_data([], [])
    return line,

# Update function for animation
def update(frame):
    t = t_values[frame]
    y = u(x, t, ylim, alpha)
    line.set_data(x, y)
    ax.set_title(f"Temperature at t = {t:.3f} unit time")
    return line,

# Create the animation
ani = FuncAnimation(fig, update, frames=len(t_values), init_func=init, blit=True)
output_file = "/content/heat_diffusion_1d_smooth.mp4"
ani.save(output_file, writer='ffmpeg', fps=60)

# Save or show the animation
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from scipy.special import erf
from google.colab import files  # For downloading in Colab

# Parameters
r0x = 17.5  # Initial x-coordinate center
r0y = 37.5  # Initial y-coordinate center
r_lim = 2.5 # Limit for error function scaling
u0 = 100    # Initial heat magnitude
alpha = 2   # Diffusion constant
t_max = 5   # Set maximum time step for 5-second animation

fps = 30  # Frames per second
output_file = "/content/heat_diffusion_2D.mp4"  # Output file name for Colab

def heat_solution(x, y, t, r0x, r0y, r_lim, u0, alpha):
    """
    Computes the temperature at a given (x, y, t) based on the 2D heat diffusion equation.
    """
    r = np.sqrt((x - r0x)**2 + (y - r0y)**2)
    term1 = erf((r_lim - r) / np.sqrt(4 * alpha * t))
    term2 = erf((-r_lim - r) / np.sqrt(4 * alpha * t))
    return (u0 / 2) * (term1 - term2)

# Grid setup
x = np.linspace(0, 50, 100)  # X-axis range
y = np.linspace(0, 50, 100)  # Y-axis range
X, Y = np.meshgrid(x, y)

# Initialize figure and axis
fig, ax = plt.subplots()
contour = ax.imshow(np.zeros_like(X), extent=[0, 50, 0, 50], origin='lower', cmap='jet', vmin=0, vmax=u0)
cbar = plt.colorbar(contour, ax=ax, label="Temperature [K]")
ax.set_title("2D Heat Diffusion Animation")
ax.set_xlabel("x")
ax.set_ylabel("y")

def update(frame):
    t = 0.1 + frame * (t_max / (fps * 5))  # Adjusted time step for smooth 5-second duration
    Z = heat_solution(X, Y, t, r0x, r0y, r_lim, u0, alpha)
    contour.set_data(Z)  # Update data for color map
    return [contour]

# Animation setup
frames = fps * 5  # 5-second animation at specified fps
ani = animation.FuncAnimation(fig, update, frames=frames, interval=1000 / fps, blit=False)

# Save animation as mp4
ani.save(output_file, writer="ffmpeg", fps=fps)
print(f"Animation saved as {output_file}")

# Return output file name
def heat_diffusion_2d():
    return output_file

# Run the function and save the animation
animation_file = heat_diffusion_2d()

# Download the file (specific for Colab)
files.download(animation_file)

plt.show()

from scipy.special import erf
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

ts = 2e16

R1 = 6400e3
R2 = 6371e3
R3 = 3486e3
R4 = 1216e3

def f(X, Y, A, t, rx0, ry0, u0, rmax):
    rr = np.sqrt((X-rx0)**2 + (Y-ry0)**2)
    return 0.5*u0*(erf((rmax-rr)/(np.sqrt(4*A*t)))-erf((-rmax-rr)/(np.sqrt(4*A*t))))

P = 200
Xlist = np.linspace(0, 6400e3, P)
Ylist = np.linspace(0, 6400e3, P)
X, Y = np.meshgrid(Xlist, Ylist)

A = np.ones((P,P))
A[True] = 1e-50
A[np.sqrt(X**2 + (Y-6400e3)**2) <= R1] = 0.25e-5
A[np.sqrt(X**2 + (Y-6400e3)**2) <= R2] = 0.25e-6
A[np.sqrt(X**2 + (Y-6400e3)**2) <= R3] = 0.25e-7
A[np.sqrt(X**2 + (Y-6400e3)**2) <= R4] = 0.2e-8

#Layered Earth Approach:
#E1 = np.zeros((P,P))
#E1[np.sqrt(X**2 + (Y-6400e3)**2) <= R1] = 300
#E1[np.sqrt(X**2 + (Y-6400e3)**2) <= R2] = 2300
#E1[np.sqrt(X**2 + (Y-6400e3)**2) <= R3] = 4100
#E1[np.sqrt(X**2 + (Y-6400e3)**2) <= R4] = 6300

fig = plt.figure()

def animate(t):
    print(f"Frame: {t+1}")
    plt.clf()
    E0 = f(X, Y, A, ts*t+1e-10, 4500e3, 1900e3, 1e8, 1e2)
    E1 = f(X, Y, A, ts*t+2e20, 0, 6400e3, 8000, R4)
    plt.imshow(E0+E1, cmap="jet", interpolation="bilinear", vmin=0, vmax=1e4, extent=(0, 6400e3, 0, 6400e3))
    plt.colorbar(label="Temperature [K]")
    plt.title(f"Elapsed time [myr]: {int(t*2e9/31536000)}")
    plt.xlabel("x axis [m]")
    plt.ylabel("y axis [m]")

anim = FuncAnimation(fig, animate, frames = 100, interval = 1, repeat=False)
anim.save("WaveComet.gif", fps = 30, dpi=200)
